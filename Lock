local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()
local camera = workspace.CurrentCamera

local fovradius = 80
local distancemax = 100

local enabled = true
local constantMode = false
local lockedTarget = nil

local gui = Instance.new("ScreenGui")
gui.Name = "FOVGui"
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")

local circle = Instance.new("Frame")
circle.Size = UDim2.fromOffset(fovradius * 2, fovradius * 2)
circle.BackgroundTransparency = 1
circle.AnchorPoint = Vector2.new(0.5, 0.5)
circle.Visible = false
circle.Parent = gui

local stroke = Instance.new("UIStroke")
stroke.Thickness = 0.5
stroke.Color = Color3.fromRGB(255, 255, 255)
stroke.Parent = circle

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(1, 0)
corner.Parent = circle

local function hasToolEquipped()
	local char = player.Character
	if not char then return false end

	for _, item in ipairs(char:GetChildren()) do
		if item:IsA("Tool") then
			return true
		end
	end

	return false
end

local function isValidTarget(char)
	local head = char:FindFirstChild("Head")
	local hrp = char:FindFirstChild("HumanoidRootPart")
	local humanoid = char:FindFirstChildOfClass("Humanoid")

	if not (head and hrp and humanoid) then
		return nil
	end

	if humanoid.Health <= 0 then
		return nil
	end

	return head, hrp
end

local function isTargetAlive(target)
	if not target then return false end
	local char = target.Parent
	if not char then return false end

	local humanoid = char:FindFirstChildOfClass("Humanoid")
	if not humanoid then return false end

	return humanoid.Health > 0
end

local function getTargetInCircle()
	if not hasToolEquipped() then
		return nil
	end

	local closest
	local shortest = fovradius

	local myChar = player.Character
	local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
	if not myHRP then return nil end

	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= player and plr.Character then
			local head, hrp = isValidTarget(plr.Character)
			if head then
				local worldDist = (hrp.Position - myHRP.Position).Magnitude
				if worldDist <= distancemax then
					local screenPos, onScreen = camera:WorldToViewportPoint(head.Position)
					if onScreen then
						local dist = (Vector2.new(mouse.X, mouse.Y)
							- Vector2.new(screenPos.X, screenPos.Y)).Magnitude

						if dist < shortest then
							shortest = dist
							closest = head
						end
					end
				end
			end
		end
	end

	return closest
end

RunService:BindToRenderStep(
	"HardCameraLock",
	Enum.RenderPriority.Camera.Value + 1,
	function()
		if enabled and constantMode then
			if not hasToolEquipped() then
				lockedTarget = nil
				return
			end

			if not lockedTarget then
				lockedTarget = getTargetInCircle()
			end

			if lockedTarget and not isTargetAlive(lockedTarget) then
				lockedTarget = nil
				return
			end

			if lockedTarget and lockedTarget.Parent then
				camera.CFrame = CFrame.new(
					camera.CFrame.Position,
					lockedTarget.Position
				)
			end
		end
	end
)

UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end

	if input.KeyCode == Enum.KeyCode.Semicolon then
		enabled = not enabled
		constantMode = false
		lockedTarget = nil
		circle.Visible = false
		return
	end

	if input.UserInputType == Enum.UserInputType.MouseButton2 and enabled then
		constantMode = true
		lockedTarget = nil
		circle.Visible = true
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		constantMode = false
		lockedTarget = nil
		circle.Visible = false
	end
end)

RunService.RenderStepped:Connect(function()
	if enabled and constantMode then
		circle.Position = UDim2.fromOffset(mouse.X, mouse.Y)
	end
end)
