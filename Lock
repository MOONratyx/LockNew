local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

local Window = Rayfield:CreateWindow({
	Name = "FOV Lock Panel",
	Icon = "target",
	LoadingTitle = "FOV Lock",
	LoadingSubtitle = "Rayfield UI",
	ShowText = "Rayfield",
	Theme = "Default",
	ToggleUIKeybind = "K",

	ConfigurationSaving = {
		Enabled = true,
		FolderName = "FOVLock",
		FileName = "Config"
	}
})

local MainTab = Window:CreateTab("FOV", "crosshair")
MainTab:CreateSection("Configurações")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local mouse = player:GetMouse()
local camera = workspace.CurrentCamera

local fovradius = 80
local distancemax = 100
local strokeThickness = 2
local strokeTransparency = 0

local enabled = true
local constantMode = false
local lockedTarget = nil

local gui = Instance.new("ScreenGui")
gui.Name = "FOVGui"
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")

local circle = Instance.new("Frame")
circle.Size = UDim2.fromOffset(fovradius * 2, fovradius * 2)
circle.BackgroundTransparency = 1
circle.AnchorPoint = Vector2.new(0.5, 0.5)
circle.Visible = false
circle.Parent = gui

local stroke = Instance.new("UIStroke")
stroke.Thickness = strokeThickness
stroke.Transparency = strokeTransparency
stroke.Color = Color3.fromRGB(255, 255, 255)
stroke.Parent = circle

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(1, 0)
corner.Parent = circle

local function hasToolEquipped()
	local char = player.Character
	if not char then return false end
	for _, item in ipairs(char:GetChildren()) do
		if item:IsA("Tool") then
			return true
		end
	end
	return false
end

local function isValidTarget(char)
	local head = char:FindFirstChild("Head")
	local hrp = char:FindFirstChild("HumanoidRootPart")
	local humanoid = char:FindFirstChildOfClass("Humanoid")

	if not (head and hrp and humanoid) then return nil end
	if humanoid.Health <= 0 then return nil end

	return head, hrp
end

local function isTargetAlive(target)
	if not target or not target.Parent then return false end
	local humanoid = target.Parent:FindFirstChildOfClass("Humanoid")
	return humanoid and humanoid.Health > 0
end

local function getTargetInCircle()
	if not hasToolEquipped() then return nil end

	local closest
	local shortest = fovradius

	local myChar = player.Character
	local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart")
	if not myHRP then return nil end

	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= player and plr.Character then
			local head, hrp = isValidTarget(plr.Character)
			if head then
				local worldDist = (hrp.Position - myHRP.Position).Magnitude
				if worldDist <= distancemax then
					local pos, onScreen = camera:WorldToViewportPoint(head.Position)
					if onScreen then
						local dist = (Vector2.new(mouse.X, mouse.Y) - Vector2.new(pos.X, pos.Y)).Magnitude
						if dist < shortest then
							shortest = dist
							closest = head
						end
					end
				end
			end
		end
	end

	for _, model in ipairs(workspace:GetDescendants()) do
		if model:IsA("Model") and not Players:GetPlayerFromCharacter(model) then
			local head, hrp = isValidTarget(model)
			if head then
				local worldDist = (hrp.Position - myHRP.Position).Magnitude
				if worldDist <= distancemax then
					local pos, onScreen = camera:WorldToViewportPoint(head.Position)
					if onScreen then
						local dist = (Vector2.new(mouse.X, mouse.Y) - Vector2.new(pos.X, pos.Y)).Magnitude
						if dist < shortest then
							shortest = dist
							closest = head
						end
					end
				end
			end
		end
	end

	return closest
end

RunService:BindToRenderStep("HardCameraLock", Enum.RenderPriority.Camera.Value + 1, function()
	if enabled and constantMode then
		if not hasToolEquipped() then
			lockedTarget = nil
			return
		end

		if not lockedTarget then
			lockedTarget = getTargetInCircle()
		end

		if lockedTarget and not isTargetAlive(lockedTarget) then
			lockedTarget = nil
			return
		end

		if lockedTarget then
			camera.CFrame = CFrame.new(camera.CFrame.Position, lockedTarget.Position)
		end
	end
end)

UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end

	if input.KeyCode == Enum.KeyCode.Semicolon then
		enabled = not enabled
		constantMode = false
		lockedTarget = nil
		circle.Visible = false
	end

	if input.UserInputType == Enum.UserInputType.MouseButton2 and enabled then
		constantMode = true
		lockedTarget = nil
		circle.Visible = true
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		constantMode = false
		lockedTarget = nil
		circle.Visible = false
	end
end)

RunService.RenderStepped:Connect(function()
	if enabled and constantMode then
		circle.Position = UDim2.fromOffset(mouse.X, mouse.Y)
	end
end)

MainTab:CreateSlider({
	Name = "Tamanho do FOV",
	Range = {20, 300},
	Increment = 1,
	CurrentValue = fovradius,
	Callback = function(v)
		fovradius = v
		circle.Size = UDim2.fromOffset(v * 2, v * 2)
	end
})

MainTab:CreateSlider({
	Name = "Distância Máxima",
	Range = {20, 500},
	Increment = 5,
	CurrentValue = distancemax,
	Callback = function(v)
		distancemax = v
	end
})

MainTab:CreateSlider({
	Name = "Stroke Thickness",
	Range = {1, 10},
	Increment = 0.5,
	CurrentValue = strokeThickness,
	Callback = function(v)
		strokeThickness = v
		stroke.Thickness = v
	end
})

MainTab:CreateSlider({
	Name = "Stroke Transparency",
	Range = {0, 1},
	Increment = 0.05,
	CurrentValue = strokeTransparency,
	Callback = function(v)
		strokeTransparency = v
		stroke.Transparency = v
	end
})

MainTab:CreateToggle({
	Name = "Mostrar FOV",
	CurrentValue = true,
	Callback = function(v)
		circle.Visible = v
	end
})
